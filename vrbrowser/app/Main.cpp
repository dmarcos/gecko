/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "steam/steam_api.h"
#include "mozilla/XREAppData.h"
#include "nsXULAppAPI.h"
#include "application.ini.h"
#include "mozilla/Bootstrap.h"
#include "nsXPCOMPrivate.h"
#include "nsCOMPtr.h"
#include "nsIFile.h"
#include "BinaryPath.h"
#include <stdio.h>

mozilla::Bootstrap::UniquePtr gBootstrap;

static void Output(const char *fmt, ... )
{
  va_list ap;
  va_start(ap, fmt);

#ifndef XP_WIN
  vfprintf(stderr, fmt, ap);
#else
  char msg[2048];
  vsnprintf_s(msg, _countof(msg), _TRUNCATE, fmt, ap);

  wchar_t wide_msg[2048];
  MultiByteToWideChar(CP_UTF8,
                      0,
                      msg,
                      -1,
                      wide_msg,
                      _countof(wide_msg));
#if MOZ_WINCONSOLE
  fwprintf_s(stderr, wide_msg);
#else
  // Linking user32 at load-time interferes with the DLL blocklist (bug 932100).
  // This is a rare codepath, so we can load user32 at run-time instead.
  HMODULE user32 = LoadLibraryW(L"user32.dll");
  if (user32) {
    decltype(MessageBoxW)* messageBoxW =
      (decltype(MessageBoxW)*) GetProcAddress(user32, "MessageBoxW");
    if (messageBoxW) {
      messageBoxW(nullptr, wide_msg, L"Firefox", MB_OK
                                               | MB_ICONERROR
                                               | MB_SETFOREGROUND);
    }
    FreeLibrary(user32);
  }
#endif
#endif

  va_end(ap);
}

//-----------------------------------------------------------------------------
// Purpose: callback hook for debug text emitted from the Steam API
//-----------------------------------------------------------------------------
extern "C" void __cdecl SteamAPIDebugTextHook( int nSeverity, const char *pchDebugText )
{
  // if you're running in the debugger, only warnings (nSeverity >= 1) will be sent
  // if you add -debug_steamapi to the command-line, a lot of extra informational messages will also be sent
  ::OutputDebugString( pchDebugText );

  if ( nSeverity >= 1 )
  {
    // place to set a breakpoint for catching API errors
    int x = 3;
    x = x;
  }
}

int main(int argc, const char* argv[])
{
  char exePath[MAXPATHLEN];

  if ( SteamAPI_RestartAppIfNecessary( k_uAppIdInvalid ) )
  {
    // if Steam is not running or the game wasn't started through Steam, SteamAPI_RestartAppIfNecessary starts the
    // local Steam client and also launches this game again.

    // Once you get a public Steam AppID assigned for this game, you need to replace k_uAppIdInvalid with it and
    // removed steam_appid.txt from the game depot.

    return 255;
  }

  // Initialize SteamAPI, if this fails we bail out since we depend on Steam for lots of stuff.
  // You don't necessarily have to though if you write your code to check whether all the Steam
  // interfaces are NULL before using them and provide alternate paths when they are unavailable.
  //
  // This will also load the in-game steam overlay dll into your process.  That dll is normally
  // injected by steam when it launches games, but by calling this you cause it to always load,
  // even when not launched via steam.
  if ( !SteamAPI_Init() )
  {
    Output( "SteamAPI_Init() failed\n" );
    return 255;
  }

  // set our debug handler
  SteamClient()->SetWarningMessageHook( &SteamAPIDebugTextHook );

  // Ensure that the user has logged into Steam. This will always return true if the game is launched
  // from Steam, but if Steam is at the login prompt when you run your game from the debugger, it
  // will return false.
  if (SteamUser()->BLoggedOn())
  {
    Output( "Steam user is logged in\n" );
  }

  nsresult rv = mozilla::BinaryPath::Get(argv[0], exePath);
  if (NS_FAILED(rv)) {
    Output("Couldn't calculate the application directory.\n");
    return 255;
  }

  char* lastSlash = strrchr(exePath, XPCOM_FILE_PATH_SEPARATOR[0]);
  if (!lastSlash || ((lastSlash - exePath) + sizeof(XPCOM_DLL) + 1 > MAXPATHLEN)) {
    Output("Couldn't calculate XPCOM shared library location.\n");
    return 255;
  }

  strcpy(++lastSlash, XPCOM_DLL);

  gBootstrap = mozilla::GetBootstrap(exePath);
  if (!gBootstrap) {
    Output("Couldn't load XPCOM.\n");
    return 255;
  }

  mozilla::BootstrapConfig config;
  // sAppData is a magical constant generated by the build system.
  config.appData = &sAppData;

  return gBootstrap->XRE_main(argc, (char**)argv, config);
}
